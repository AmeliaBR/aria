<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
<title>Accessible Name and Description: Computation and API Mappings 1.1</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<script src="../common/script/jquery-1.9.0.min.js"></script>
<script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
<script src="../common/script/resolveReferences.js" class="remove"></script>
	<script src="../common/biblio.js" class="remove"></script>
<link href="http://www.w3.org/StyleSheets/TR/W3C-ED" rel="stylesheet" type="text/css"/>
<link href="../common/css/mapping-tables.css" rel="stylesheet" type="text/css"/>
<link href="../common/css/common.css" rel="stylesheet" type="text/css"/>

<script class="remove">
  var respecConfig = {
    includePermalinks: true,
    
    // specification status (e.g., WD, LC, NOTE, etc.). If in doubt use ED.
    specStatus:           "ED",
    //crEnd:                "2012-04-30",
    //perEnd:               "2013-07-23",
    //publishDate:           "2013-08-22",
    diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

    // the specifications short name, as in http://www.w3.org/TR/short-name/
    shortName:            "accname-aam-1.1",
          
    // if you wish the publication date to be other than today, set this
    //publishDate:  "2014-12-11",
    copyrightStart:  "2014",

    // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
    // and its maturity status
    //previousPublishDate:  "2014-03-20",
    //previousMaturity:     "REC",
    prevRecURI:           "http://www.w3.org/TR/2014/REC-wai-aria-implementation-20140320/",
    previousDiffURI:      "http://www.w3.org/TR/2014/REC-wai-aria-implementation-20140320/",

    // if there a publicly available Editors Draft, this is the link
    edDraftURI:           "http://w3c.github.io/aria/accname-aam/accname-aam.html",

    // if this is a LCWD, uncomment and set the end of its review period
    // lcEnd: "2012-02-21",

    // editors, add as many as you like
    // only "name" is required
    editors:  [
        { name: "Joseph Scheuhammer",
          company: "Inclusive Design Research Centre, OCAD University",
          companyURI:"http://idrc.ocad.ca"
        },
        { name: "James Craig",
          url: 'http://www.apple.com',
				  mailto: "jcraig@apple.com",
				  company: "Apple Inc.", 
				  companyURI: "http://www.apple.com"
        },
        { name: "Andi Snow-Weaver (until December 2012)",
          company: "IBM",
          companyURI: "http://www.ibm.com"
        },
        { name: "Aaron Leventhal (until January 2009)",
          company: "IBM",
          companyURI: "http://www.ibm.com" },
    ],
    // authors, add as many as you like. 
    // This is optional, uncomment if you have authors as well as editors.
    // only "name" is required. Same format as editors.

    //authors:  [
    //    { name: "Your Name", url: "http://example.org/",
    //      company: "Your Company", companyURI: "http://example.com/" },
    //],

	/*
    alternateFormats: [
          { uri: 'aria-implementation-diff.html',
            label: "Diff from Previous Recommendation" } ,
          { uri: 'aria-implementation.ps',
            label: "PostScript version" },
          { uri: 'aria-implementation.pdf',
            label: "PDF version" }
    ],
    */
    
    // Working group info
    wg:           "Accessible Rich Internet Applications Working Group",
    wgURI:        "http://www.w3.org/WAI/ARIA/",
    wgPublicList: "public-aria",

    // URI of the patent status for this WG, for Rec-track documents
    // !!!! IMPORTANT !!!!
    // This is important for Rec-track documents, do not copy a patent URI from a random
    // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
    // Team Contact.
    wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/83726/status",
    
    tocIntroductory: true,
    //maxTocLevel: 4,
    
    // Spec URLs
    ariaSpecURLs: {
      "ED": "http://w3c.github.io/aria/aria/aria.html",
      "WD" : "http://www.w3.org/TR/wai-aria-1.1/",
      "FPWD": "http://www.w3.org/TR/wai-aria-1.1/",
      "REC": "http://www.w3.org/TR/wai-aria/"
    },
    coreMappingURLs: {
       "ED": "http://w3c.github.io/aria/core-aam/core-aam.html",
       "WD" : "http://www.w3.org/TR/core-aam-1.1/",
       "FPWD": "http://www.w3.org/TR/core-aam-1.1/",
       "REC": "http://www.w3.org/TR/wai-aria-implementation/"
    },

    localBiblio: biblio,
    
    preProcess: [ linkCrossReferences ]
  }
</script>
<script src="../common/script/jquery.details.min.js"></script>
<script src="../common/script/mapping-tables.js"></script>
</head>
<body>
<section id="abstract">
	<p>This document describes how <a class="termref">user agents</a> determine <a class="termref" data-lt="accessible name">names</a> and <a class="termref" data-lt="accessible description">descriptions</a> of <a class="termref">accessible objects</a> from web content languages and expose them in <a class="termref">accessibility <abbr title="Application Programming Interfaces">APIs</abbr></a>. This allows <a class="termref">assistive technologies</a> to associate and relay the name or description of objects to users. Documenting the algorithm and mappings promotes interoperable exposure of these properties and events as implemented by different accessibility APIs, and helps to ensure that this information appears in a manner consistent with author intent. </p>
	<p>The accessible name and description computation and mappings specification defines support that applies across multiple content technologies. This includes accessible name and description provided by general-purpose <cite><a href="http://www.w3.org/TR/wai-aria-1.1/"><abbr title="Accessible Rich Internet Applications">WAI-ARIA</abbr></a></cite> [[!WAI-ARIA]] <a class="termref">roles</a>, <a class="termref">states</a>, and <a class="termref">properties</a> as well as features specific to individual content languages. The accessible name and description computation extends the mapping guidance provided by <cite><a href="http://www.w3.org/TR/core-aam-1.1/"><abbr title="Core Accessibility API Mappings 1.1">CORE-AAM</abbr></a></cite> [[!CORE-AAM]] and technology-specific accessibility API mappings. </p>
	<p>This document updates and will eventually supersede the accessible name and description guidance in the <a href="http://www.w3.org/TR/wai-aria-implementation/">WAI-ARIA 1.0 User Agent Implementation Guide</a> [[!WAI-ARIA-IMPLEMENTATION]] W3C Recommendation. It is part of the <abbr title="Accessible Rich Internet Applications">WAI-ARIA</abbr> suite described in the <a href="http://www.w3.org/WAI/intro/aria.php"><abbr title="Accessible Rich Internet Application">WAI-ARIA</abbr> Overview</a>.</p>
</section>
<section id="sotd">
</section>
<section id="intro">
	<h2>Introduction</h2>
      <p>This section is <a class="termref">informative</a>.</p>
      <p><a class="termref">User agents</a> acquire information from the <abbr title="Document Object Model">DOM</abbr> and create a parallel structure called the <a class="termref">accessibility tree</a>, made up of <a class="termref">accessible objects</a>.  An accessible object provides information about its <a class="termref">role</a>, <a class="termref">states</a>, and <a class="termref">properties</a>.  An example is an accessible object whose role is <code>menuitem</code>, is currently in an <code>enabled</code> state, with a <code>haspopup</code> property, indicating that it leads to a sub-menu.  </p>
      <p>The two properties of accessible objects described in this document are its <a class="termref">accessible name</a> and <a class="termref">accessible description</a>.  The name is a short label that provides information about the purpose of the object.  An example of an accessible name for a menu item is <code>New</code>, signifying that the menu item provides for the creation of new documents, windows, and so on.  </p>
      <p>The description is a short explanation that further clarifies the nature of the accessible object.  It is not always necessary to provide a description  if the name is sufficient, but it can help a user better understand the use of the object.</p>
      <p><a class="termref">Accessibility <abbr title="Application Programming Interfaces">APIs</abbr></a> currently support flat, unstructured strings for accessible names and descriptions.  The result of the name/description computation is thus a flat string. </p>      
      <p>The terms "accessible name" and "accessible description" are used to emphasize that they are properties of <a class="termref">accessible objects</a> as exposed by <a class="termref">Accessibility <abbr title="Application Programming Interfaces">APIs</abbr></a>.  However, they are frequently referred to hereafter as simply "name" and "description".</p>
</section>
<section id="normative" class="normative">
	<h2>Normative User Agent Implementation Requirements for <abbr title="Accessible Rich Internet Applications">WAI-ARIA</abbr></h2>
	<p>This section is <a class="termref">normative</a>.</p>
	<p>This specification indicates whether a section is <a class="termref">normative</a> or <a class="termref">informative</a> and the classification applies to the entire section. A statement "This section is normative" or "This section is informative" applies to all sub-sections of that section.</p>
	<p>Normative sections provide requirements that <a class="termref">user agents</a> must follow for an implementation to conform to this specification. The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, RECOMMENDED, MAY, and OPTIONAL in this document are to be interpreted as described in <cite><a href="http://www.rfc-editor.org/rfc/rfc2119.txt">Keywords for use in RFCs to indicate requirement levels</a></cite> [[!RFC2119]]. RFC-2119 keywords are formatted in uppercase and contained in a <code>strong</code> element with <code>class="rfc2119"</code>. When the keywords shown above are used, but do not share this format, they do not convey formal information in the RFC 2119 sense, and are merely explanatory, i.e., informative. As much as possible, such usages are avoided in this specification.</p>
	<p>Informative sections provide information useful to understanding the specification. Such sections may contain examples of recommended practice, but it is not required to follow such recommendations in order to conform to this specification.</p>
</section>
<section id="glossary">
  <h2>Important Terms</h2>
  <p>This section is <a class="termref">normative</a>.</p>
  <div data-include="../common/terms.html" data-oninclude="fixIncludes"></div>
  <p class="ednote">
    (Amelia) Is there any way to subset the common terms list to only print out terms that are actually used in this document?  More than half of these terms are not used anywhere in this specification.
  </p>
</section>
<section id="mapping_additional_nd" class="normative">
  <h2>Name and Description</h2>
  <p>This section is <a class="termref">normative</a>.</p>
  <p>
    This section describes how and when user agents should compute the name and description for elements in the document.  
    The purpose of the computation is to create a <a class="termref">perceivable</a> label or description for alternative presentations, in the form of a flat string.
    In a WAI-ARIA conforming document, elements that a user interacts with or that represent landmarks on the page need an accessible name to be perceivable and therefore <a class="termref">operable</a>.  Elements which are not fully <a class="termref">understandable</a> based solely on the name, role, and text content (in the absence of imagery or styling information) can be made so with an appropriate accessible description.
  </p>
  <p>
    The starting point of the name and description computation is a <abbr title="Document Object Model">DOM</abbr> <a class="termref">element</a>.  Depending on the semantics of the element (as indicated with ARIA roles and properties or with host language features), these alternative text representations may be derived from the element's attributes, its child content, or from other elements in the document.  The <a href="#mapping_additional_nd_te">Text Alternative Computation</a> provides a deterministic algorithm for determining the correct alternative text for a given document model (including styling instructions).  Some steps in the algorithm refer to host language features; separate specifications for the most common web languages will explicitly define how these features should be interpreted. 
  </p>
  <section id="terminology">
    <h3>Terminology</h3>
    <p>
      Alternative text may in some cases be generated from child contents, or from a relationships to another element.  As a result, the text computation is partially recursive.  However, the text generated from each node may be different when it is processed recursively than if it is assessed directly.  For this reason, the  <a href="#mapping_additional_nd_te">text alternative computation</a> algorithms use the following terms to distinguish why a given node is being processed:
    </p>
    <dl>
      <dt>the original node</dt> <dd>The DOM element associated with the accessible object for which an accessible name or description is required.</dd>
      <dt id="term-current-node">the current node</dt> 
          <dd>The node currently being processed by the algorithm to determine a text alternative, regardless of how the algorithm arrived at this node.</dd>
      <dt id="term-labelling-node">a labelling node</dt> 
          <dd>A node that is being processed because of an explicit labelling relationship that was indicated by the author using ARIA attributes or host language semantics.</dd>
      <dt id="term-content-node">a content node</dt> 
          <dd>A node that is being processed because it forms part of the child content of the original node.</dd>
      <dt id="term-content-labelling-node">content of a labelling node</dt> 
          <dd>A node that is being processed because it forms part of the child content of a labelling node.</dd>
    </dl>
    <p class="ednote">
      The wording "original node" is used instead of "root node", because the latter has a distinct meaning when discussing a document object model.  The other terms are introduced to avoid having to repeat text at multiple stages of the algorithm (such as iterating all the ways in which one node can label another).
    <p>
      Three types of nodes are considered when processing content, each of which uses a different text alternative algorithm: 
    </p>
    <dl>
      <dt id="term-DOM-elements">DOM elements</dt> 
          <dd>An element in the document object model, possibly with attributes, dynamic DOM properties, and child content.  The text equivalent of the element may be generated from any of these features, and the correct text will often depend on roles, other ARIA properties, or semantics of the host language.</dd>
      <dt id="term-DOM-text-node">DOM text nodes</dt> 
          <dd>A section of text content that exists in the document object model, as the sole child content of an element or as a string of text in between two child elements.</dd>
      <dt id="term-CSS-generated-content">CSS-generated content nodes</dt> 
          <dd>CSS styling introduces content into the rendered document that is not directly contained in the document object model.  This generated content may be text or image; a proposed CSS property would allow stylesheet authors to indicate appropriate alternative text for generated content. A complete text representation of any element will include CSS-generated content, so the alternative text computation proceeds as if text nodes existed for this content.</dd>
    </dl>
    <p>
      The final output of either alternative text computation (name or description) is a flat, unstructured string, without styling information or markup.
      Text alternatives are normalized to flat strings according to the following definitions:
    </p>
    <dl>
      <dt id="term-flat-string">Flat string</dt>
          <dd>A string that only contains character data; it does not contain any markup or styling information.  Furthermore, all whitespace characters are replaced with a single space, and multiple consecutive spaces are reduced to a single space.</dd> 
      <dt id="term-whitespace">Whitespace</dt>
          <dd>Any of the following characters: spaces, carriage returns, newlines, tabs, and form-feeds.</dd>
    </dl>
    <p class="ednote">
      (Amelia) Is a more precise definition of whitespace characters appropriate?  If so, should it be the narrow set of characters that HTML/XML use for whitespace collapsing, or the much broader class of Unicode whitespace characters?
    </p>
  </section>
  <section id="mapping_additional_nd_name">
    <h3>Name Computation</h3>
    <p>
      <a class="termref">User agents</a> MUST compute an <a class="termref">accessible name</a> for every element that is represented by an <a class="termref">accessible object</a> in the <a class="termref">accessibility tree</a>, using the rules outlined below in the section titled <a href="#mapping_additional_nd_te">Text Alternative Computation</a>.  Authors MUST ensure that the computation yields a non-empty accessible name for any element whose computed role has a value of true for the property <code>accessible name required</code> in the WAI-ARIA specifications [[!WAI-ARIA]].
    </p>
    <p class="ednote">
      (Amelia) I've added in the clarification about which elements require accessible names to be calculated.
    </p>
    <p class="ednote">
      (Amelia) The requirement on authors is consistent with the main ARIA spec, but it may not be appropriate to have author-focused requirements in this specification.  Also, the <code>accessible name required</code> property of each role, although indicated in the role's characteristics table, is not clearly defined in that specification.
    </p>
    <p>
      The name may be as simple as a single word, or a string of space-separated tokens.  Examples of valid names include <code>Save</code> and <code>Reload from disk</code>.  For elements where names are not required by the element's role, the result of the computation may be an empty string.
    </p>
    <p>
      The name does not include the description of the element's role (such as "button" or "slider"), which is communicated to assistive technologies separately.
    </p>    
    <p>
      An important factor in the name computation is the <a class="termref">element</a>'s <a class="termref">role</a>, which determines what content contributes to the name string.  The impact of the computed role is the same regardless of whether it was explicitly specified by the author or derived from the host language semantics.  Roles have a <code>nameFrom</code> <abbr title="Resource Description Framework">RDF</abbr> property, with two possible values:  </p>
    <dl class="runin">
      <dt>author</dt>
      <dd>name is generated from values provided by the author in explicit markup features such as the <code>aria-label</code> and <code>aria-labelledby</code> <a class="termref">attribute</a>, or a host language labeling mechanism, such as the <code>alt</code> or <code>title</code> <a class="termref">attribute</a> in <abbr title="Hypertext Markup Language">HTML</abbr>, or the <code>desc</code> <a class="termref">element</a> in <abbr title="Scalable Vector Graphics">SVG</abbr>. </dd>
      <dt>contents</dt>
      <dd>name is generated from the <a class="termref" data-lt="text node">text nodes</a> and child elements associated with the <a class="termref">element</a>. Although this may be allowed in addition to "author" in some <a class="termref">roles</a>, "content" is used only if higher priority "author" features are not provided. Priority is defined by the <a href="#mapping_additional_nd_te">text alternative computation</a> algorithm.</dd>
    </dl>
    <p class="ednote">(Joseph) Need links into ARIA spec to (1) a list of nameFrom:author roles, and (2) a list of nameFrom:contents roles.  Reference these at step 5 of the text alternative for an element algorithm. </p>
    <p>
  </section>
  <section id="mapping_additional_nd_description">
    <h3>Description Computation</h3>
    <p>
      Accessible descriptions are used to provide textual representations of graphics or additional context for widgets.  Descriptions are often longer than names, in the form of fully punctuated sentences.  The accessible description generated by this computation is nonetheless still a flat string.  However, that flat description may be complemented by the declared relationship to the fully structured elements from which it is derived, which assistive technologies can make accessible to users through other means.
    </p>
    <p>
      <a class="termref">User agents</a> MUST compute an accessible description for an element that is represented by an <a class="termref">accessible object</a> in the <a class="termref">accessibility tree</a> in any of the following cases:
    </p>
    <ul>
      <li>An <a class="property-reference" href="#aria-describedby"><code>aria-describedby</code></a> attribute was provided for that element.</li>
      <li>A labelling relationship has been provided using host language features, other than a labelling relationship that was used to generate the accessible name.</li>
      <li>Alternative text or tooltip text was provided using host language features.</li>
    </ul>
    <p>
      The text description is generated following the methods outlined in the section titled <a href="#mapping_additional_nd_te">Text Alternative Computation</a>. 
      In the absence of explicit labelling relationships or tooltip elements, descriptions are not generated from an element's contents.
    </p>
    <p>
      After computing both the accessible name and the accessible description for the element according to the algorithm (including whitespace normalization), user agents MUST compare the two.  If the entirety of the description is contained within the name, then there is no accessible description for the element.
    </p>
    <p class="ednote">
      (Amelia) The requirements for generating an accessible description have been extended to include host-language features as well as <code>aria-describedby</code>.  I'm not sure if user agents currently compute descriptions in all these cases; that may be an argument for making some of these points SHOULD instead of MUST.  The requirement to compare the name and description, and drop redundant descriptions, replaces step-by-step requirements to check whether a given text alternative has already been used.
    </p>
  </section>
  <section id="mapping_additional_nd_te">
    <h3>Text Alternative Computation</h3>
    <p>
      The text alternative computation is used to generate both the <a class="termref">accessible name</a> and <a class="termref">accessible description</a>. It consists of a set of algorithms for determining a text alternative for each node type: <a href="#mapping_additional_nd_te_element">DOM elements</a>, <a href="#mapping_additional_nd_te_node">DOM text nodes</a>, and <a href="#mapping_additional_nd_te_css-alt">CSS-generated text nodes</a>.  In addition, an <a href="#mapping_additional_nd_te_css-insert">algorithm is provided for inserting the CSS-generated text nodes within the DOM tree structure</a>.
    </p>
    <p>
      For the <a href="#mapping_additional_nd_te_element">Text Alternative for an Element</a> algorithm, some steps are different for names versus descriptions, for original nodes versus labelling nodes or content nodes, as well as for certain element <a class="termref">roles</a> or for markup combinations that represent host language semantic features.
    </p>
    <p>
      The computation is initialized by running the <a href="#mapping_additional_nd_te_element">Text Alternative for an Element</a> algorithm on the original node.  Some of the options are recursive, requiring text alternatives to be calculated for one or more other nodes in the document.
    </p>
    <p>       
      The text alternative returned for the original node (including the concatenated alternatives for other nodes where required) is used as that element's <a class="termref">accessible name</a> or <a class="termref">accessible description</a> after normalizing whitespace.  User agents MAY perform whitespace normalization to meet the definition of a flat string after processing each node, or once only after compiling the final string.  User agents SHOULD trim leading and trailing whitespace from the final compiled name or description, but MUST NOT do so at intermediary stages (which could result in whitespace being omitted incorrectly).
    </p>
    <section id="mapping_additional_nd_te_element">
      <h4>Text Alternative for an Element</h4>
      <p>The text alternative for a DOM element is computed as follows:</p>
        <ol>
          <li id="step-element-ariaby">
            If the <a href="#term-current-node"><var>current node</var></a> is the <a href="#term-original-node"><var>original node</var></a> or a <a href="#term-content-node"><var>content node</var></a>, <strong>and</strong> it has a non-empty <code>aria-labelledby</code> <a class="termref">attribute</a> (if computing a <a class="termref" data-lt="accessible name">name</a>) or <code>aria-describedby</code> <a class="termref">attribute</a> (if computing a <a class="termref" data-lt="accessible description">description</a>):
            <ol>
              <li id="step-element-ariaby-recurse">
                <p>
                  For each token in the relevant attribute, in the order they are specified, if
                </p>
                <ul>
                  <li>that token is a <a>valid IDREF</a> referencing an element in the document, <strong>and</strong></li>
                  <li>the referenced element is <strong>either</strong> the <a href="#term-current-node"><var>current node</var></a> or it is another element that has <strong>not</strong> been previously processed in the course of generating the alternative text for the <a href="#term-original-node"><var>original node</var></a>,</li>
                </ul>
                <p>
                  then generate a text alternative for the referenced element using this <a href="#mapping_additional_nd_te_element">Text Alternative for an Element</a> algorithm, with the referenced element as the <a href="#term-current-node"><var>current node</var></a> and as a <a href="#term-labelling-node"><var>labelling node</var></a>.
                </p>
              </li>
              <li id="step-element-ariaby-join">
                <p>
                  Concatenate the returned text alternatives, separated by spaces, in the order that the IDREFs were specified in the <code>aria-labelledby</code> or <code>aria-describedby</code> attribute, and return the resulting string.
                </p>
              </li>
            </ol>
            <div><details>
              <summary>Comment and example:</summary>
              <p>
                The requirement to consider whether alternative text has previously been collected from an element, prior to following a labelling relationship, avoids repetitive content and unexpected loops in the algorithm. 
              </p>
              <p>
                Because <code>aria-labelledby</code> and <code>aria-describedby</code> attributes are only processed for the <a href="#term-original-node"><var>original node</var></a> or a <a href="#term-content-node"><var>content node</var></a>, these labelling relationships are <strong>not</strong> recursive.  This can lead to missing alternative text if an author is not careful. In the following snippet, the names would be computed as follows:
              </p>
              <ul>
                <li><code>element1</code>'s  <a class="termref">accessible name</a> is "hello" (assuming its role supports names from contents).</li>
                <li><code>element2</code>'s <a class="termref">accessible name</a> is also "hello" because the <code>aria-labelledby</code> attribute leads to <code>element1</code>.</li>
                <li><code>element3</code> has no <a class="termref">accessible name</a>.  The computation involves a first traversal of its <code>aria-labelledby</code> leading to <code>element2</code>, but <code>element2</code>'s  <code>aria-labelledby</code> is not subsequently followed, and it does not otherwise provide an accessible name. </li>
                <li><code>element4</code>'s <a class="termref">accessible name</a> is "good-bye" because the first traversal of its <code>aria-labelledby</code> attribute leads to <code>element3</code>, but <code>element3</code>'s <code>aria-labelledby</code> attribute is now ignored when it is processed as a labelling node, allowing the <code>aria-label</code> attribute to be used instead.</li></li>
              </ul>
              <pre class="example highlight"><code>&lt;element1 id="el1"&gt; hello &lt;/element1&gt;
&lt;element2 id="el2" aria-labelledby="el1" /&gt;
&lt;element3 id="el3" aria-labelledby="el2" aria-label="good-bye" /&gt;
&lt;element4 id="el4" aria-labelledby="el3" /&gt;</code>
              </pre>
            </details></div>
            <p class="ednote">
              (Amelia) The requirement to avoid repeated content was previously only mentioned in the step for concatenating child content; it seemed appropriate to also express it here.
            </p>
          </li>
          <li id="step-element-embedded-control">
            Otherwise, if the <a href="#term-current-node"><var>current node</var></a> is a <a href="#term-content-node"><var>content node</var></a> or <a href="#term-content-labelling-node"><var>content of a labelling node</var></a> <strong>and</strong> the <a href="#term-current-node"><var>current node</var></a>'s computed role is an <a class="role-reference" href="#input">input</a> or a <a class="role-reference" href="#range">range</a> (or a subclass thereof), then return the current value of the input, as follows:
            <ul>
              <li id="step-element-embedded-control-textbox">
                <p>
                  If the embedded control has role <a class="role-reference" href="#textbox">textbox</a>, return its current value as determined by host language features, if they exist, or else determine its text alternative from its contents by following the process in <a href="step-element-contents">Step 5</a>.
                </p>
              </li>
              <!--<li>If the embedded control has role menu <a class="role-reference" href="#button">button</a>, return the text alternative of the button.</li>-->
              <li id="step-element-embedded-control-select">
                <p>
                  If the embedded control has a <a class="role-reference" href="#combobox">select</a> role (e.g., <rref>listbox</rref> or <rref>combobox</rref>), determine text alternatives for the current user-input text value (via host language semantics for the selection element or as the current value of the first descendent element with a <a class="role-reference" href="#textbox">textbox</a> role) and any selected descendent <a class="role-reference" href="#option">option</a> elements (determined via host language semantics or via running this algorithm on option elements with the <code>aria-selected="true"</code> state).  Return these values, concatenated in order, separated by spaces.
                </p>
              </li>
              <li id="step-element-embedded-control-range">
                <p>
                  If the embedded control has a <a class="role-reference" href="#range">range</a> role (e.g., a <a class="role-reference" href="#spinbutton">spinbutton</a> or <a class="role-reference" href="#slider">slider</a>):
                </p>
                <ul>
                  <li>If the <code>aria-valuetext</code> property is present, return its value, </li>
                  <li>Otherwise, if the <code>aria-valuenow</code> property is present, return its value,</li>
                  <li>Otherwise, use the current value as specified by a host language feature. </li>
                </ul>
              </li>
            </ul>
            <div><details>
              <summary>Example:</summary>
              <p>Consider a <a class="role-reference" href="#checkbox">check box</a> label that contains a text input field: "Remind me in [input] minutes". If the user has entered "5" for the embedded <a class="role-reference" href="#textbox">textbox</a>, the complete label is "Remind me in 5 minutes", e.g.: </p>
              <pre class="example highlight"><code>&lt;div role="checkbox" aria-checked="false" &gt;Remind me in &lt;span role="textbox" aria-multiline="false" contenteditable="true"&gt; 5 &lt;/span&gt; minutes&lt;/div&gt;</code></pre>
            </details></div>
            <p class="ednote">
              (Amelia) The "current value" for custom widgets is normally represented with plain text content of component elements, but may also be represented with CSS generated content tied to a data attribute.  Native widgets represent the value with special properties; for example, an HTML <code>input</code> element of type <code>text</code> uses an IDL property to hold the current value, and can also have a placeholder value which appears in the text box when the current value is empty.  The current wording tries to incorporate all the possibilities; it will be complemented by specifics in the HTML-AAM specification.
            </p>
            <p class="ednote">
              (Amelia) Various changes have been made to the original text (which stems from ARIA 1.0), to reference the abstract superclass roles wherever appropriate.  I have also removed any mention of a "selected menuitem" within a menu as an example of a user-input widget with a changeable value.  It's inclusion did not seem to be consistent with the concept of menus as a collection of distinct commands (rather than as a selection).
            </p>
          </li>
          <li id="step-element-label">
            Otherwise, if computing a <a class="termref" data-lt="accessible name">name</a>, and if the <a href="#term-current-node"><var>current node</var></a> has a non-empty <code>aria-label</code> <a class="termref">attribute</a>, return the value of <code>aria-label</code>.
            <div><details>
              <summary>Comment and Example:</summary>
              <p>
                Because of the priority order presented here, an <code>aria-label</code> value is normally not used for that element's name if an <code>aria-labelledby</code> attribute is present.  However, the <code>aria-label</code> value may be incorporated in the name if the element itself is recursively referenced by its own <code>aria-labelledby</code> attribute.  When the text alternative algorithm is run recursively on the element, it is treated as a <a href="#term-labelling-node"><var>labelling node</var></a> and <code>aria-labelledby</code> is skipped.  This allows authors to concatenate the text of a visible label with additional alternative text. 
              </p>
              <p>The following example shows the interaction of <code>aria-labelledby</code> and <code>aria-label</code> when a <a class="termref">node</a> has an  <code>aria-labelledby</code> that refers to itself.  The <code>&lt;span role="button"&gt;</code> elements have the <a class="termref">accessible names</a> "Delete Documentation.pdf" and "Delete HolidayLetter.pdf", respectively.</p>
                <pre class="example highlight"><code>&lt;h1&gt;Files&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
  &lt;a id=&quot;file_row1&quot; href=&quot;./files/Documentation.pdf&quot;&gt;Documentation.pdf&lt;/a&gt;
  <strong>&lt;span role=&quot;button&quot; tabindex=&quot;0&quot; id=&quot;del_row1&quot; aria-label=&quot;Delete&quot; aria-labelledby=&quot;del_row1 file_row1&quot;&gt;✖&lt;/span&gt;</strong>
&lt;/li&gt;
&lt;li&gt;
  &lt;a id=&quot;file_row2&quot; href=&quot;./files/HolidayLetter.pdf&quot;&gt;HolidayLetter.pdf&lt;/a&gt;
  <strong>&lt;span role=&quot;button&quot; tabindex=&quot;0&quot; id=&quot;del_row2&quot; aria-label=&quot;Delete&quot; aria-labelledby=&quot;del_row2 file_row2&quot;&gt;✖&lt;/span&gt;</strong>
&lt;/li&gt;
&lt;/ul&gt;</code></pre>
              </details></div>
          </li>
          <li id="step-element-native">Otherwise, if host language semantics for the <a href="#term-current-node"><var>current node</var></a> provide an <a class="termref">attribute</a> that defines a text alternative for the name or description, as appropriate, return that attribute's value as a <code>flat string</code>.  If the host language semantics define another <a class="termref">element</a> as the text alternative name or description, generate a text alternative from that element by  <a href="#mapping_additional_nd_te_element">Text Alternative for an Element</a> algorithm, with the referenced element as the <a href="#term-current-node"><var>current node</var></a> and as a <a href="#term-labelling-node"><var>labelling node</var></a>, unless that element has been explicitly marked as presentational (<code>role="presentation"</code> or <code>role="none"</code>) by the author.
            <p class="ednote">
              (Amelia) I'm not sure how much I've changed the wording taken "from second note in <a href="https://www.w3.org/WAI/PF/Group/track/issues/522">ISSUE-522</a>", which I can't access.  However, the changes were made for two reasons: make it clear that a host-language labelling relationship to another element causes a recursive processing of the algorithm; make it clear that alternative text elements (such as SVG's title/desc) that by default have no role are not excluded.
            </p>
            <div><details>
              <summary>Comment:</summary>
              <p>
                For example, in <abbr title="Hypertext Markup Language">HTML</abbr>, the <code>img</code> element's <code>alt</code> attribute defines a text alternative string, and the <code>label</code> element provides text for the referenced form element.  In <abbr title="Scalable Vector Graphics">SVG</abbr>, the <code>desc</code> and <code>title</code> elements provide a description and a label, respectively, for their parent element. 
              </p>
            </details></div>
          <li id="step-element-contents">Otherwise, if the <a href="#term-current-node"><var>current node</var></a> is <strong>not</strong> the <a href="#term-original-node"><var>original node</var></a>, <strong>or</strong> if computing an <a>accessible name</a> and the <a href="#term-current-node"><var>current node</var></a>'s computed <a class="termref">role</a> allows "Name From: contents":
            <ol>
              <li id="step-element-contents-css">
                <p>
                Follow the <a href="#mapping_additional_nd_te_css-insert">algorithm for inserting <abbr title="Cascading Style Sheets">CSS</abbr>-generated text nodes</a> for the <a href="#term-current-node"><var>current node</var></a> into its child content.
                </p>
              </li>
              <li id="step-element-contents-hidden">
                <p>
                  Exclude all child nodes of the <a href="#term-current-node"><var>current node</var></a> that are <a class="termref">hidden</a>,
                  <strong>unless</strong> the <a href="#term-current-node"><var>current node</var></a> is <strong>also</strong> hidden itself.
                </p>
              </li>
              <li id="step-element-contents-children">
                <p>
                  For each remaining child node of the <a href="#term-current-node"><var>current node</var></a>, in order&mdash;including child elements, DOM text nodes (even if only containing whitespace), and the inserted CSS-generated text nodes&mdash;calculate a text alternative by running the appropriate algorithm with the node as a <a href="#term-content-node"><var>content node</var></a> (if the <a href="#term-current-node"><var>current node</var></a> is the <a href="#term-original-node"><var>original node</var></a> or a <a href="#term-content-node"><var>content node</var></a>) or as <a href="#term-content-labelling-node"><var>content of labelling node</var></a> (if the <a href="#term-current-node"><var>current node</var></a> is a <a href="#term-labelling-node"><var>labelling node</var></a> or <a href="#term-content-labelling-node"><var>content of labelling node</var></a>).
                </p>
                <p>
                  Before processing each child element, determine whether that element has been previously processed by this algorithm in the course of generating the text alternative for the <a href="#term-original-node"><var>original node</var></a>.  If it has, do not process the element a second time, but instead treat it as a hidden node.
                </p>
              </li>
              <li id="step-element-contents-whitespace">
                <p>
                  Concatenate the text alternatives of the child content, in order. If the <a href="#term-current-node"><var>current node</var></a> is displayed (or would be displayed in visual media) with a line break before and after its content (e.g., <abbr title="Cascading Style Sheets">CSS</abbr> <code>block</code> or <code>list-item</code> display modes), append a space before and after the concatenated content; do not append spaces if the element is displayed inline.  Return the concatenated string as the text alternative for the <a href="#term-current-node"><var>current node</var></a>.
                </p>
              </li>
            </ol>
            <div><details>
              <summary>Comment and Examples:</summary>
              <p>
                This step can apply recursively to child elements, resulting in text collected from all the elements in the <a href="#term-current-node"><var>current node</var></a>'s subtree, no matter how deep it is. However, any given descendant <a class="termref">element</a>'s text alternative may result from explicit labelling markup provided by the author, instead of from its subtree. 
              </p>
              <p>
                Because it is a recursive algorithm, there is a potential for infinite loops. For this reason, both this step and <a href="step-element-ariaby">Step 1</a> require user agents to determine whether they have already processed a given element before processing it a second time. The following snippet of an HTML form shows two cases where this check prevents a loop:
              </p>
<pre class="example highlight"><code>&lt;label&gt;&lt;input type="number" name="count" min="0" required /&gt; 
  Number of copies 
  &lt;span&gt;(required)&lt;/span&gt;&lt;/label&gt;
&lt;button type="submit"&gt;
  &lt;img src="shopping-cart.svg" aria-labelledby="cart-label" /&gt; 
  &lt;span id="cart-label"&gt;Add to Cart&lt;/span&gt;
&lt;/button&gt;
</code></pre>
              <p>
                The accessible name for the <code>input</code> element is derived from it's containing <code>label</code>, 
                according to the native semantics of HTML.  
                The label has no special attributes defining a name, 
                so its text alternative will be derived from its contents.  
                The first of those content nodes is the <code>input</code> element itself, 
                but that will be skipped because it has already been processed.  
                The text node and span that form the rest of the label contents will therefore be used for the input's name.
              </p>
              <p>
                If CSS is used to hide the "(required)" text once the input has a valid value,
                then that node will be excluded from the contents and therefore the name.
                By default, <a class="termref">assistive technologies</a> do not relay hidden information, 
                although an author can explicitly override that 
                and include hidden text as part of the <a class="termref">accessible name</a> or <a class="termref">accessible description</a> 
                by using <code>aria-labelledby</code> or <code>aria-describedby</code>, or other host language labelling mechanisms.  
                A hidden labelling node will be used, as will its contents if required.
              </p>
              <p>
                The submit button in the code snippet does not have any labelling attributes or elements. 
                The button's name will therefore be derived from its contents, 
                consistent with the <code>button</code> <a>role</a>.
                The first content element (after a whitespace node) is an icon <code>img</code>, 
                which is labelled "Add to Cart" by an adjacent <code>span</code>.  
                The <code>span</code> is also a child of the <code>button</code>; 
                however, it is not processed a second time because of the check in this step against duplicate contents.  
                If the <code>span</code> had been before the <code>img</code> in the markup, 
                the check at <a href="step-element-ariaby">Step 1</a> would have prevented the duplication, 
                prior to processing the icon's <code>aria-labelledby</code> attribute.  
                Either way, the button's accessible name would be simply the string "Add to Cart".  
              </p>
              <p>
                On smaller screen sizes, the visible text button label may be hidden,
                so the button's only visible content is the icon.
                In that case, the label will be omitted from the button's contents,
                but it's text will still be used as alternative text for the icon.
              </p>
              <p>
                The requirement to insert whitespace before and after the content string, conditional upon the element's display mode, reflects the implied word breaks created by block styling, without introducing inappropriate word breaks within inline content.  In the following snippet, the accessible name for the checkbox would be "Make this the topmost element" (with no space after "top"), but the accessible names for both buttons would be "Top it Up"&mdash;in the first case because of the explicit whitespace nodes, but in the second case because of the implicit formatting breaks (assuming the normal block styling of <code>p</code> elements in HTML was not altered).
              </p>
<pre class="example highlight"><code>&lt;label&gt; &lt;input type="checkbox" /&gt; Make this the &lt;em&gt;top&lt;/em&gt;most element&lt;/label&gt;
&lt;button&gt;&lt;em&gt;Top&lt;/em&gt; &lt;em&gt;it&lt;/em&gt; &lt;em&gt;Up&lt;/em&gt;&lt;/button&gt;
&lt;button&gt;&lt;p&gt;Top&lt;/p&gt;&lt;p&gt;it&lt;/p&gt;&lt;p&gt;Up&lt;/p&gt;&lt;/button&gt;
</code></pre>
            </details></div>
            <p class="ednote">
              The check for hidden content has been moved here, instead of as the first step of the element algorithm, because it only applies when dealing with contents, not labelling nodes, and because we need to ensure that an element that is skipped (as contents) because it is hidden will <strong>not</strong> be skipped again (as a duplicate) if it is referenced in a labelling relationship.  Putting the test at this point in the algorithm also helps deal with the HTML <code>details</code> element and arbitrary text in SVG files, for which text nodes may be hidden even though their parent element is displayed.  The check for whether the current node is also hidden allows hidden labelling nodes to work as expected (even though their contents would be hidden as well).
            </p>
          </li>
          <li id="step-element-tooltip">
            Otherwise, if host language features provide content for the <a href="#term-current-node"><var>current node</var></a> that is normally displayed as a tooltip, return the tooltip's text value as a flat string, padded before and after with spaces. 
              <p class="ednote">
                (Amelia)  The tooltip may therefore end up as the accessible name or as the accessible description, depending on what other alternative text is provided.  The check against duplicate description content prevents it from being both. The use of tooltips as descriptions is something we've discussed for the SVG accessibility mappings.  Tooltips can be important text content that the author provided to pointer users, and it would ideally therefore be accessible to AT users.  However, it is additional content, that should not replace the visible text content or proper label.  I have also changed the wording from "tooltip attribute" to allow for other host language features (i.e., the <code>title</code> child element in SVG).
              </p>
            <div><details>
              <summary>Comment and Example:</summary>
              <p>
                Tooltip are only used as an accessible name if no other labelling mechanism has been provided, and the element's role does not support names from content.  Because tooltips are usually written as supplemental information for users of visual displays and pointer input, they are more suitable as additional descriptions rather than as labels or alternative text.
              </p>
              <p>
                If the tooltip content should be presented in addition to a more detailed description, the <code>aria-describedby</code> attribute can be used to reference the existing element (and its tooltip) in addition to another element (with a full description).  For example, when a tooltip is used to provide an extra punchline to a visual joke, it should be appended to a description of the graphical content, as in the following example:
              </p>
<pre class="example highlight"><code>&lt;img id="image" src="sleepy-kitty.jpg" 
    aria-describedby="description image"
    alt="I hate Mondays"
    title="also applies to Tuesdays, Wednesdays, Thursdays, and Fridays" /&gt;
&lt;p id="description" class="off-screen"&gt;
  Photograph of a messy bed, with a cat-sized lump under the blankets and a cat's tail peeking out.
  Text says 'I hate Mondays…'.
&lt;/p&gt;
</code></pre>
              <p>The graphic would have the accessible name "I hate Mondays",
                based on the native alternative text attribute (<code>alt</code>) for the HTML <code>img</code> element.
                The accessible description, concatenated from the description paragraph and the tooltip defined by the HTML <code>title</code> attribute,  would be:
              </p>
              <blockquote>
                Photograph of a messy bed, with a cat-sized lump under the blankets and a cat's tail peeking out.
  Text says 'I hate Mondays…'. also applies to Tuesdays, Wednesdays, Thursdays, and Fridays
              </blockquote>
            </details></div>
          </li>
        </ol>
  
  </section>
  <section id="mapping_additional_nd_te_node">
    <h4>Text Alternative for a Text Node</h4>
    
    <p>  
      The text alternative for a DOM text node is its text content, including leading or trailing whitespace characters, converted to a flat string.
    </p>
  </section>
  <section id="mapping_additional_nd_te_css-insert">
    <h4>Inserting CSS-Generated Text Nodes</h4>
    
    <p>
      When generating alternative text from the content of an element, the computations should proceed as if text nodes existed in the DOM tree for CSS-generated content, as follows:
    </p>
    <ul>
      <li>
        <p>
          If the <a href="#term-current-node"><var>current node</var></a> is a list element (those for which the computed value of either the <a href="http://www.w3.org/TR/CSS2/generate.html#propdef-list-style-type"><code>list-style-type</code></a> or <a href="http://www.w3.org/TR/CSS2/generate.html#propdef-list-style-image"><code>list-style-image</code></a> <abbr title="Cascading Style Sheets">CSS</abbr> properties is something other than <code>none</code>), a list marker node should be inserted <strong>before</strong> any child content (including text nodes) in the <abbr title="document object model">DOM</abbr>.
        </p>
      </li>
      <li>
        <p>
          If the <a href="#term-current-node"><var>current node</var></a> has a <code>before</code> pseudo-element whose <code>content</code> property is not <code>normal</code> and whose <code>display</code> property is not <code>none</code>, a corresponding pseudo-element node should be inserted <strong>after</strong> any list marker node but <strong>before</strong> any child content (including text nodes) in the <abbr title="document object model">DOM</abbr>.
        </p>
      </li>
      <li>
        <p>
          If the <a href="#term-current-node"><var>current node</var></a> has an <code>after</code> pseudo-element whose <code>content</code> property is not <code>normal</code> and whose <code>display</code> property is not <code>none</code>, a corresponding pseudo-element node should be inserted <strong>after</strong> any child content (including text nodes) in the <abbr title="document object model">DOM</abbr>.
        </p>
      </li>
    </ul>
  </section>
  <section id="mapping_additional_nd_te_css-alt">
    <h4>Text Alternative for CSS-Generated Content</h4>
    <p>
      The text alternative for CSS-generated content is generated as follows:
    </p>
    <ul>
      <li>
        <p>
          For list marker nodes, return text equivalent to the <a href="http://www.w3.org/TR/css-counter-styles-3/#counter-style-speak-as"><code>speak-as</code></a> value defined for the list counter system as described in CSS Counter Styles Level 3 [[CSS-COUNTER-STYLES-3]].  If the user agent does not support <code>speak-as</code>, the following rules should be used:
        </p>
        <ul>
          <li>
            When <code>list-style-image</code> is not <code>none</code>, or when <code>list-style-type</code> is <code>disc</code>, <code>circle</code>, or <code>square</code>, use a standard user agent representation of a bullet, such as the character U+2022 (&#x2022;).
          </li>
          <li>
            For all other <code>list-style-type</code> values, use the actual text characters created for the marker.
          </li>
        </ul>
        </p>
          In all cases, the list marker is padded before and after with spaces.  
        </p>
      </li>
      <li>
        <p>
          For pseudo-element nodes, 
        </p>
        <ul>
          <li>
            If the pseudo-element has a property that defines alternative text content, use that alternative text content converted to a flat string.  
          </li>
          <li>
            Otherwise, if the pseudo-element's content property results in the generation of text characters, use that text content converted to a flat string.
          </li>
          <li>
            If the pseudo-element's content consists only of an image or an empty string, and no alternative text is provided, return an empty string.
          </li>
        </ul>
        <p>
          If the result of the above steps is not an empty string, and the pseudo-element node is displayed with a line break before and after its content (e.g., <abbr title="Cascading Style Sheets">CSS</abbr> <code>block</code> display mode), append a space before and after the text; do not append a space if the element is displayed inline.  Return the resulting string as the text alternative for the node.
        </p>
      </li>
    </ul>
    <div class="note">
      <p>
        CSS Counter Styles Level 3 introduced custom counter styles and the <a href="http://www.w3.org/TR/css-counter-styles-3/#counter-style-speak-as"><code>speak-as</code> descriptor</a>.  The <code>speak-as</code> option provides a way for decorative characters (e.g., circled numbers: ❶, ❷, ❸) to be replaced with a simpler alternative (e.g., regular numbers: 1, 2, 3) for speech rendering or other plain text presentations [[CSS-COUNTER-STYLES-3]].
      </p>
      <p>
        The wording regarding alternative text for CSS-generated content is intentionally open-ended, as <a href="https://drafts.csswg.org/css-content/#alt-property">proposals for this feature in CSS are still in the early draft stage</a>.
      </p>
    </div>
    <p class="ednote">
      The information regarding alternative text for CSS-generated content is new.  In addition, I have simplified the rules for list markers to always add whitespace, without needing to check whether the marker already includes a space or not; the whitespace normalization rules for "flat strings" should take care of duplicate consecutive spaces.  For pseudo-elements, however, I've added in the check for inline versus block content, with whitespace adjusted accordingly.
    </p>
  </section>
    </section>
  </section>
  <section>
    <h3>Accessible Name and Description Mapping</h3>
    <p>The algorithm generates a <code>flat text string</code> for each element, which is then trimmed of excess whitespace.  The result is a single flat string name or description associated with the <a class="termref">element</a> for which the text alternative computation was executed.  The computed string is used to set the <a class="termref">accessible name</a> or <a class="termref">accessible description</a> <a class="termref">property</a> of the <a class="termref">accessible object</a> corresponding to the <a class="termref">element</a>.  The specifics of  each <a class="termref">accessibility <abbr title="Application Programming Interfaces">API</abbr></a> mapping is given in the following table.</p>
    <table id="nameMappingTable">
    <caption>
      Accessible name and accessible description mapping table
    </caption>
    <thead>
      <tr>
        <th>Accessibility <abbr title="Application Programming Interfaces">API</abbr> Property</th>
        <th>MSAA + IAccessible2 </th>
        <th><abbr title="User Interface Automation">UIA</abbr></th>
        <th><abbr title="Accessibility Toolkit">ATK</abbr>/<abbr title="Assistive Technology-Service Provider Interface">AT-SPI</abbr></th>
        <th><abbr title="Mac OS X Accessibility Protocol">AXAPI</abbr></th>
      </tr>
    </thead>
    <tbody>
    <tr id="accName">
      <th><a class="termref"><code>accessible name</code></a></th>
      <td>Expose in <code>accName</code> property.
      <p><code>aria-labelledby</code>:  If the referenced objects are in the accessibility tree expose pointers to them using <code>IA2_RELATION_LABELLED_BY</code>, and expose reverse relations as described in <a class="core-mapping" href="#mapping_additional_relations">Relations</a>. </p>
      </td>
      <td>Expose in <code>Name</code> property.
        <p><code>aria-labelledby</code>:  If the referenced objects are in the accessibility tree, expose pointers to them using the <code>LabeledBy</code> property.</p>
      </td>
      <td>Expose in the name property of the accessible object.
        <p><code>aria-labelledby</code>: If the referenced objects are in the accessibility tree, expose pointers to them using <code>RELATION_LABELLED_BY</code>, and expose reverse relations as described in <a class="core-mapping" href="#mapping_additional_relations">Relations</a>. </p>
      </td>
      <td>Expose as <code>string AXTitle</code>, <code>AXDescription</code>, or <code>AXTitleUIElement</code>:
        <ul>
        <li>Accessible name values that are exposed visually, as in the case of a button, should be exposed as string <code>AXTitle</code>. </li>
        <li><code>AXDescription</code> is recommended for accessible name values that are not exposed visually, such as <code>@alt</code> and <code>@aria-label</code>. </li>
        </ul>
        <p><code>aria-labelledby</code>: </p>
        <ul>
          <li>If <code>aria-labelledby</code> references a single element, expose the labeling relationship as element <code>AXTitleUIElement</code>. </li>
          <li>If <code>aria-labelledby</code> references multiple elements, or if the labeling element is invisible or otherwise not exposed in the accessibility tree, expose as <code>string AXDescription</code>. </li>
        </ul>
      </td>
    </tr>
    <tr id="accDesc">
      <th><a class="termref"><code>accessible description</code></a></th>
      <td>Expose in <code>accDescription</code> property.
        <p><code>aria-describedby</code>: If the referenced objects are in the accessibility tree, expose pointers to them using <code>IA2_RELATION_DESCRIBED_BY</code>, and expose reverse relations as described in <a class="core-mapping" href="#mapping_additional_relations">Relations</a>.</p>
      </td>
      <td>TBD.
        <p><code>aria-describedby</code>: If the referenced objects are in the accessibility tree, expose pointers to the referenced accessible objects using the <code>DescribedBy</code> property.</p>
        <p>(See <a href="https://www.w3.org/WAI/PF/Group/track/actions/1104"><strong>ACTION-1104</strong></a>)</p>
      </td>
      <td>Expose in the description property of the accessible object.
        <p><code>aria-describedby</code>: If the referenced objects are in the accessibility tree, expose reverse relations as described in <a class="core-mapping" href="#mapping_additional_relations">Relations</a>.</p>
      </td>
      <td>Expose as <code>string AXHelp</code>.</td>
    </tr>
  </tbody>
  </table>
    <p>More information concerning name and description accessibility API mappings, including relationships, such as labelled-by/label-for and described-by/description-for, is documented in the <a class="core-mapping" href="">Core Accessibility <abbr title="Application Programming Interface">API</abbr> Mappings</a> document [[!CORE-AAM]].  See the mapping table entries for <a class="core-mapping" href="#ariaLabel"><code>aria-label</code></a>, <a class="core-mapping" href="#ariaLabelledBy"><code>aria-labelledby</code></a>, and <a class="core-mapping" href="#ariaDescribedBy"><code>aria-describedby</code></a>.  </p>
  </section>
	<section id="events">
	<h2>Name and Description Change Events</h2>
    <p class="ednote">(Joseph) Certain Accessibility APIs emit events for name and/or description property changes.  Document that here (see, for example, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=991969" target="_blank">FF bugzilla 991969</a>).</p>
    <p>Although rare, sometimes an <a class="termref">accessible name</a> or <a class="termref">accessible description</a> may change.  Examples include: </p>
    <ul>
      <li>Buttons such as the "Play" button in a media player whose label can switch between "Pause" and "Play" depending on its state. </li>
      <li>On/Off switches whose label changes between "On" and "Off". </li>
      <li>Labels with embedded controls as described in <a href="#step-element-embedded-control">step 2 of the text alternative algorithm for an element</a>, since the user can change the value of the embedded control. </li>
      <li>Situations where description text is loaded or set only when needed, such as when the mouse hovers over an object, or the object gains focus. </li>
    </ul>
    <p>The following table lists the events or notifications provided by Accessibility <abbr title="Application Programming Interfaces">APIs</abbr> if the name or description changes. <a class="termref">Assistive technologies</a> can make use of these events to provide the current label as needed. </p>
    <table id="nameDescChangeEvents">
    <caption>
      Table of events fired in each API for changes in name or desription property.
    </caption>
    <thead>
      <tr>
        <th>Accessibility <abbr title="Application Programming Interfaces">API</abbr> Property</th>
        <th>MSAA + IAccessible2 </th>
        <th><abbr title="User Interface Automation">UIA</abbr></th>
        <th><abbr title="Accessibility Toolkit">ATK</abbr>/<abbr title="Assistive Technology-Service Provider Interface">AT-SPI</abbr></th>
        <th><abbr title="Mac OS X Accessibility Protocol">AXAPI</abbr></th>
      </tr>
    </thead>
    <tbody>
    <tr id="accNameChange">
      <th><a class="termref"><code>accessible name</code></a></th>
      <td><code>EVENT_OBJECT_NAMECHANGE</code></td>
      <td><code>PropertyChangeEvent</code></td>
      <td><code>object:property-change:accessible-name</code></td>
      <td><code>TitleChangedNotification</code></td>
    </tr>
    <tr id="accDescChange">
      <th><a class="termref"><code>accessible description</code></a></th>
      <td><code>EVENT_OBJECT_DESCRIPTIONCHANGE</code></td>
      <td><code>PropertyChangeEvent</code></td>
      <td><code>object:property-change:accessible-description</code></td>
      <td>TBD.</td>
    </tr>
  </tbody>
  </table>
	</section>
<section>
  <h2>Appendices</h2>
	<section class="appendix" id="changelog">
		<h2>Change Log</h2>
		<section>
			<h2>Substantive changes since the <a href="http://www.w3.org/TR/2014/WD-accname-aam-1.1-20141211/">last public working draft</a></h2>
			<ul>
				<li>05-Nov-2015: Removed all MSAA+UIA Express mappings.</li>
				<!-- EdNote: After each WD publish, move contents of this list into the next one below.  -->
			</ul>
		</section>
		<section>
			<h2>Other substantive changes since the <a href="http://www.w3.org/TR/2014/REC-wai-aria-implementation-20140320/">WAI-ARIA 1.0 User Agent Implementation Guide Recommendation</a></h2>
			<ul>
				<li>10-Jun-2015: Moved special case of unlabeled <code>&lt;img&gt;</code> to HTML-AAM.</li>
				<li>05-Jan-2015: Glossary entry for "value" removed; removed links to that entry.</li>
				<!-- EdNote: After each WD publish, move previous list into this one. -->
			</ul>
		</section>
	</section>  <div data-include='../common/acknowledgements.html' data-include-replace='true'></div>
</section>
</body>
</html>

